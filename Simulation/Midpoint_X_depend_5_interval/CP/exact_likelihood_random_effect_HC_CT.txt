model {

  # Historical Data
  


	#Block 3: Right Censoring Block
	for ( i in (idxI[2]+1):idxR) {
	# Pieces of the cumulative hazard function
		for (k in 1: lower.int.obs[i]) {
			lower.cond[i , k] <- step(L[i] - kappa[k + 1])
			lower.HH[i,k] <- lower.cond[i ,k] * (kappa[k + 1] - kappa[k]) * exp(alpha[k]) +
			(1 - lower.cond[i,k] ) * (L[i] - kappa[k]) * exp(alpha[k])
		}

	# Cumulative hazard function
	lower.H[i] <- sum(lower.HH[i,1:lower.int.obs[i]])
	}

	for (i in (idxI[2]+1):idxR) {
		# Linear predictor
		elinpred[i] <- exp(inprod(beta[ ] , X[i,] ) + mu[i] )
		# Log-hazard function
		#logHaz[ i ] <- log(lambda[int.obs[i]] * elinpred[i])
		# survival function
		lower.Surv[i] <- exp(-lower.H[i] * elinpred[i])
		# Definition of the log-likelihood using zeros trick
		#phi[i] <- 100000 - delta[i] * logHaz[i] - logSurv[i]
		#phi[i] <- 100000 - log(lower.Surv[i])
		phi[i] <- lower.Surv[i]/100000000000
		#zeros[i] ~ dpois(phi[i])
		ones[i] ~ dbern(phi[i])
	}


	#Block 4: Exact Event Block
	for ( i in (idxR+1):idxE) {
	# Pieces of the cumulative hazard function
		for (k in 1: lower.int.obs[i]) {
			lower.cond[i , k] <- step(L[i] - kappa[k + 1])
			lower.HH[i,k] <- lower.cond[i ,k] * (kappa[k + 1] - kappa[k]) * exp(alpha[k]) +
			(1 - lower.cond[i,k] ) * (L[i] - kappa[k]) * exp(alpha[k])
		}

	# Cumulative hazard function
	lower.H[i] <- sum(lower.HH[i,1:lower.int.obs[i]])
	}

	for (i in (idxR+1):idxE) {
		# Linear predictor
		elinpred[i] <- exp(inprod(beta[ ] , X[i,] ) + mu[i] )
		# hazard function
		haz[i] <- exp(alpha[lower.int.obs[i]]) * elinpred[i]
		# survival function
		lower.Surv[i] <- exp(-lower.H[i] * elinpred[i])
		# Definition of the log-likelihood using zeros trick
		#phi[i] <- 100000 - delta[i] * logHaz[i] - logSurv[i]
		#phi[i] <- 100000000000000 - log(haz[i] * lower.Surv[i])
		phi[i] <- haz[i] * lower.Surv[i]/100000000000
		#zeros[i] ~ dpois(phi[i])
		ones[i] ~ dbern(phi[i])
	}


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	#Current Trial Data
	



	#Block 3: Right Censoring Block
	for ( i in (idxI.C[2]+1):idxR.C) {
	# Pieces of the cumulative hazard function
		for (k in 1: lower.int.obs.C[i]) {
			lower.cond.C[i , k] <- step(L.C[i] - kappa[k + 1])
			lower.HH.C[i,k] <- lower.cond.C[i ,k] * (kappa[k + 1] - kappa[k]) * exp(alphaC[k]) +
			(1 - lower.cond.C[i,k] ) * (L.C[i] - kappa[k]) * exp(alphaC[k])
		}

	# Cumulative hazard function
	lower.H.C[i] <- sum(lower.HH.C[i,1:lower.int.obs.C[i]])
	}

	for (i in (idxI.C[2]+1):idxR.C) {
		# Linear predictor
		elinpred.C[i] <- exp(inprod(betaC[ ] , X.C[i,] ) + mu.C[i] + gammaC*trt.C[i] )
		# Log-hazard function
		#logHaz[ i ] <- log(lambda[int.obs[i]] * elinpred[i])
		# survival function
		lower.Surv.C[i] <- exp(-lower.H.C[i] * elinpred.C[i])
		# Definition of the log-likelihood using zeros trick
		#phi[i] <- 100000 - delta[i] * logHaz[i] - logSurv[i]
		#phi.C[i] <- 100000 - log(lower.Surv.C[i])
		phi.C[i] <- lower.Surv.C[i]/100000000000
		#zeros.C[i] ~ dpois(phi.C[i])
		ones.C[i] ~ dbern(phi.C[i])
	}


	#Block 4: Exact Event Block
	for ( i in (idxR.C+1):idxE.C) {
	# Pieces of the cumulative hazard function
		for (k in 1: lower.int.obs.C[i]) {
			lower.cond.C[i , k] <- step(L.C[i] - kappa[k + 1])
			lower.HH.C[i,k] <- lower.cond.C[i ,k] * (kappa[k + 1] - kappa[k]) * exp(alphaC[k]) +
			(1 - lower.cond.C[i,k] ) * (L.C[i] - kappa[k]) * exp(alphaC[k])
		}

	# Cumulative hazard function
	lower.H.C[i] <- sum(lower.HH.C[i,1:lower.int.obs.C[i]])
	}

	for (i in (idxR.C+1):idxE.C) {
		# Linear predictor
		elinpred.C[i] <- exp(inprod(betaC[ ] , X.C[i,] ) + mu.C[i] + gammaC*trt.C[i] )
		# hazard function
		haz.C[i] <- exp(alphaC[lower.int.obs.C[i]]) * elinpred.C[i]
		# survival function
		lower.Surv.C[i] <- exp(-lower.H.C[i] * elinpred.C[i])
		# Definition of the log-likelihood using zeros trick
		#phi[i] <- 100000 - delta[i] * logHaz[i] - logSurv[i]
		#phi.C[i] <- 100000000000000 - log(haz.C[i] * lower.Surv.C[i])
		phi.C[i] <- haz.C[i] * lower.Surv.C[i]/100000000000
		#zeros.C[i] ~ dpois(phi.C[i])
		ones.C[i] ~ dbern(phi.C[i])

	}	

	

	#Random Effect
	for(i in 1 : n.C){
		mu.C[i] ~ dnorm(0,nu)
	}
	nu ~ dgamma(0.01,0.01)
	
	for(i in 1 : n){
	  mu[i] = mu.C[idxcluster[i]]
	}
	
	gammaC ~ dnorm(0,0.0001)

#######################################################################################
#Additional block of code using DP.
    
    zz[1] <- 1/(st*st);
    st ~ dunif(0.01,100);
    zz[2] = 200;

    for (m in 1:(p+nint)) {
	pp[m,1] <- vv[m,1];
	pp[m,2] <- vv[m,2] * (1 - vv[m,1]) * pp[m,1]/vv[m,1] 
	
	for(jj in 1 : 2){
	    vv[m,jj] ~ dbeta(1,0.05) T(0.00000000001,0.9999999999) #1% prior borrowing
        }

	# sum of pp[]
	p.sum[m] <- sum(pp[m,])
	prob_cluster[m,1] <- pp[m,1]/p.sum[m]
	prob_cluster[m,2] <- pp[m,2]/p.sum[m]

    }


                 
  # Commensurate Prior

	for (j in 1:p){
		 beta[j] ~ dnorm(0,0.0001);
		 cc[j] ~ dcat(prob_cluster[j,]);
     		 betaC[j] ~ dnorm(beta[j],zz[cc[j]]);
	  }

       #Generalized for K intervals
       alpha[1] ~ dnorm(0,0.0001);
       cc[p+1] ~ dcat(prob_cluster[p+1,]);
       alphaC[1] ~ dnorm(alpha[1],zz[cc[p+1]]);
       aaa <- 1/(saa*saa);
       saa ~ dunif(0.01,100);
       
       aaa1 <- 1/(saa1*saa1);
       saa1 ~ dunif(0.01,100);
  
	for(k in 2: nint){
		alpha[k] ~ dnorm(alpha[k-1],aaa);
		cc[p+k] ~ dcat(prob_cluster[p+k,]);
		#alpha[k] ~ dnorm(alpha0[k],zz[cc[p+k]]);
		#alphaC[k] ~ dnorm(ifelse(equals(cc[p+k],2),alpha[k],alphaC[k-1]),zz[cc[p+k]]);

		alphaC[k] ~ dnorm(ifelse(equals(cc[p+k],2),alpha[k],alphaC[k-1] ),ifelse(equals(cc[p+k],2),zz[cc[p+k]], aaa1 ) );
		#alphaC[k] ~ ifelse(equals(cc[p+k],2), dnorm(alpha[k],zz[cc[p+k]]), dnorm(alphaC[k-1],aaa1));

	}
######################################################################################
	
	
}